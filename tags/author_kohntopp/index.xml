<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>author_kohntopp on Percona Community</title><link>https://percona.community/tags/author_kohntopp/</link><description>Recent content in author_kohntopp on Percona Community</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© Percona Community. MySQL, InnoDB, MariaDB and MongoDB are trademarks of their respective owners.</copyright><lastBuildDate>Tue, 18 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://percona.community/tags/author_kohntopp/index.xml" rel="self" type="application/rss+xml"/><item><title>MySQL: Tracing a single query with PERFORMANCE_SCHEMA</title><link>https://percona.community/blog/2022/10/18/mysql-tracing-a-single-query-with-performance_schema/</link><pubDate>Tue, 18 Oct 2022 00:00:00 +0000</pubDate><guid>https://percona.community/blog/2022/10/18/mysql-tracing-a-single-query-with-performance_schema/</guid><description>My task is to collect performance data about a single query, using PERFORMANCE_SCHEMA (P_S for short) in MySQL, to ship it elsewhere for integration with other data.
In a grander scheme of things, I will need to define what performance data from a query I am actually interested in. I will also need to find a way to attribute the query (as seen on the server) to a point in the codebase of the client, which is not always easy when an ORM or other SQL generator is being used.</description></item><item><title>Embracing the Stream</title><link>https://percona.community/blog/2020/12/10/embracing-the-stream/</link><pubDate>Thu, 10 Dec 2020 10:33:29 +0000</pubDate><guid>https://percona.community/blog/2020/12/10/embracing-the-stream/</guid><description>So this happened: CentOS Project shifts focus to CentOS Stream
The future of the CentOS Project is CentOS Stream, and over the next year we’ll be shifting focus from CentOS Linux, the rebuild of Red Hat Enterprise Linux (RHEL), to CentOS Stream, which tracks just ahead of a current RHEL release. CentOS Linux 8, as a rebuild of RHEL 8, will end at the end of 2021. CentOS Stream continues after that date, serving as the upstream (development) branch of Red Hat Enterprise Linux.</description></item><item><title>Not JOINing on PERFORMANCE_SCHEMA</title><link>https://percona.community/blog/2020/12/01/not-joining-on-performance_schema/</link><pubDate>Tue, 01 Dec 2020 19:22:46 +0000</pubDate><guid>https://percona.community/blog/2020/12/01/not-joining-on-performance_schema/</guid><description>The tables in PERFORMANCE_SCHEMA (P_S) are not actually tables. You should not think of them as tables, even if your SQL works on them. You should not JOIN them, and you should not GROUP or ORDER BY them.
Unlocked memory buffers without indexes The stuff in P_S has been created with “keep the impact on production small” in mind. That is, from a users point of view, you can think of them as unlocked memory buffers - the values in there change as you look at them, and there are precisely zero stability guarantees.</description></item><item><title>On the Observability of Outliers</title><link>https://percona.community/blog/2020/11/23/on-the-observability-of-outliers/</link><pubDate>Mon, 23 Nov 2020 17:41:16 +0000</pubDate><guid>https://percona.community/blog/2020/11/23/on-the-observability-of-outliers/</guid><description>At work, I am in an ongoing discussion with a number of people on the Observability of Outliers. It started with the age-old question “How do I find slow queries in my application?” aka “What would I want from tooling to get that data and where should that tooling sit?”
As a developer, I just want to automatically identify and isolate slow queries!
Where I work, we do have SolarWinds Database Performance Monitor aka Vividcortex to find slow queries, so that helps.</description></item></channel></rss>